#include <iostream>
class Vector // Класс- вектор
{
	double* p; // Указатель на массив (вектор)
	int n; // Размерность вектора (число элементов) массива
public:
	Vector(double* p, int n) // Коструктор на входе массив, задающий вектор
	{
		this->n = n; // Задаем число элементов
		this->p = new double[n]; // Выделяем память
		for (int i = 0; i < n; i++) this->p[i] = p[i]; // Копируем один массив в другой
	}

	Vector(const Vector& V)
	{ // Конструктор копирования
		n = V.n;
		p = new double[n];
		for (int i = 0; i < n; i++)
			p[i] = V.p[i];
	}

	// Конструктор перемещения
	Vector(Vector&& V)  // Параметр - правосторонняя ссылка
		: p(V.p), n(V.n)   // Можно инициализировать так
	{
		//p = M.p;  // Или инициализировать так
		//n = M.n;
		// Присвойте данным-членам исходного объекта значения по умолчанию. Это не позволяет деструктору освобождать память
		V.p = nullptr;
		V.n = 0;
	}

	void print() const // Печать вектора (массива), заменить на перегрузку <<
	{
		for (int i = 0; i < n; i++)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}

	Vector() { p = nullptr; n = 0; } // Конструктор без параметров, задает "пустой" объект

	double& operator[](int index) // Оператор- функция (перегрузка операции 
		// обращения к элементу)
	{
		return p[index];
	}
	Vector& operator =(Vector& v2) // Оператор- функция копирования объекта 
	{
		n = v2.n;
		if (p != nullptr) delete[] p; // Освобождаем память старого вектора
		p = new double[n]; // Выделяем память для нового вектора
		for (int i = 0; i < n; i++) p[i] = v2.p[i];
		return *this; // Возвращаем ссылку на текущий объект
	}
	
	~Vector() // Деструктор
	{
		if (p != nullptr) delete[] p; // Освобождаем память
	}
	friend Vector& operator *(double x, Vector& v2); // Дружественная функция, 
	// определенная вне класса
};
// Умножение числа на вектор (первый операнд не объект класса, 
// функция обязательно определяется вне класса)
Vector& operator *(double x, Vector& v2) // Оператор- функция вне класса 
{
	double* p = new double[v2.n]; // Создаем новый массив
	for (int i = 0; i < v2.n; i++) p[i] = x * v2.p[i]; // Заполняем массив
	Vector* pV = new Vector(p, v2.n); // Создаем новый объект на основе массива
	delete[] p; // Освобождаем массив
	return *pV; // Возвращаем ссылку на объект
}

int main()
{
	double m1[] = { 22, 2, 3, 4.5, 7 };
	Vector V1(m1, 5); // Создаем объект
	V1.print(); // Печать объекта
	for (int i = 0; i < 5; i++)
		std::cout << V1[i] << " "; // Пример обращения к операции []
	std::cout << std::endl;
	V1[0] = 10.6; // Пример обращения к операции []
	V1.print(); // Печать объекта
	Vector V2; // Новый объект (вначале "пустой")
	V2 = 100 * V1; // Пример выполнение перегруженной операции *     
	// V2=operator *(100, V1);
	V2.print(); // Печать полученного объекта
	return 0;
}